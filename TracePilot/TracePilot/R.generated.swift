// This is a generated file, do not edit!
// Generated by R.swift, see https://github.com/mac-cain13/R.swift

import UIKit

struct R {
  static func validate() {
    storyboard.main.validateImages()
    storyboard.main.validateViewControllers()
  }
  
  struct image {
    static var appIcon: UIImage? { return UIImage(named: "AppIcon") }
  }
  
  struct nib {
    static var launchScreen: _R.nib._LaunchScreen { return _R.nib._LaunchScreen() }
  }
  
  struct reuseIdentifier {
    
  }
  
  struct segue {
    
  }
  
  struct storyboard {
    struct main {
      static var sessionVC: UIViewController? { return instance.instantiateViewController(withIdentifier: "SessionVC") as? UIViewController }
      static var historyVC: UIViewController? { return instance.instantiateViewController(withIdentifier: "HistoryVC") as? UIViewController }
        
      static var initialViewController: UINavigationController? { return instance.instantiateInitialViewController() as? UINavigationController }
      static var instance: UIStoryboard { return UIStoryboard(name: "Main", bundle: nil) }

      
      static func validateImages() {
        
      }
      
      static func validateViewControllers() {
        assert(sessionVC != nil, "[R.swift] ViewController with identifier 'spaceshipsVC' could not be loaded from storyboard 'Main' as 'UIViewController'.")
        assert(historyVC != nil, "[R.swift] ViewController with identifier 'crewVC' could not be loaded from storyboard 'Main' as 'UIViewController'.")
      }
    }
  }
}

struct _R {
  struct nib {
    struct _LaunchScreen: NibResource {
      var instance: UINib { return UINib.init(nibName: "LaunchScreen", bundle: nil) }
      
      func firstView(_ ownerOrNil: AnyObject?, options optionsOrNil: [AnyHashable: Any]?) -> UIView? {
        return instantiateWithOwner(ownerOrNil, options: optionsOrNil)[0] as? UIView
      }
      
      func instantiateWithOwner(_ ownerOrNil: AnyObject?, options optionsOrNil: [AnyHashable: Any]?) -> [AnyObject] {
        return instance.instantiate(withOwner: ownerOrNil, options: optionsOrNil) as [AnyObject]
      }
    }
  }
}

struct ReuseIdentifier<T>: CustomStringConvertible {
  let identifier: String
  
  var description: String { return identifier }
}

protocol NibResource {
  var instance: UINib { get }
}

protocol Reusable {
  associatedtype T
  
  var reuseIdentifier: ReuseIdentifier<T> { get }
}

extension UITableView {
  func dequeueReusableCellWithIdentifier<T : UITableViewCell>(_ identifier: ReuseIdentifier<T>, forIndexPath indexPath: IndexPath?) -> T? {
    if let indexPath = indexPath {
      return dequeueReusableCell(withIdentifier: identifier.identifier, for: indexPath) as? T
    }
    return dequeueReusableCell(withIdentifier: identifier.identifier) as? T
  }
  
  func dequeueReusableCellWithIdentifier<T : UITableViewCell>(_ identifier: ReuseIdentifier<T>) -> T? {
    return dequeueReusableCell(withIdentifier: identifier.identifier) as? T
  }
  
  func dequeueReusableHeaderFooterViewWithIdentifier<T : UITableViewHeaderFooterView>(_ identifier: ReuseIdentifier<T>) -> T? {
    return dequeueReusableHeaderFooterView(withIdentifier: identifier.identifier) as? T
  }
  
  func registerNib<T: NibResource>(_ nibResource: T) where T: Reusable, T.T: UITableViewCell {
    register(nibResource.instance, forCellReuseIdentifier: nibResource.reuseIdentifier.identifier)
  }
  
  func registerNibForHeaderFooterView<T: NibResource>(_ nibResource: T) where T: Reusable, T.T: UIView {
    register(nibResource.instance, forHeaderFooterViewReuseIdentifier: nibResource.reuseIdentifier.identifier)
  }
  
  func registerNibs<T: NibResource>(_ nibResources: [T]) where T: Reusable, T.T: UITableViewCell {
    nibResources.map(registerNib)
  }
}

extension UICollectionView {
  func dequeueReusableCellWithReuseIdentifier<T: UICollectionViewCell>(_ identifier: ReuseIdentifier<T>, forIndexPath indexPath: IndexPath) -> T? {
    return dequeueReusableCell(withReuseIdentifier: identifier.identifier, for: indexPath) as? T
  }
  
  func dequeueReusableSupplementaryViewOfKind<T: UICollectionReusableView>(_ elementKind: String, withReuseIdentifier identifier: ReuseIdentifier<T>, forIndexPath indexPath: IndexPath) -> T? {
    return dequeueReusableSupplementaryView(ofKind: elementKind, withReuseIdentifier: identifier.identifier, for: indexPath) as? T
  }
  
  func registerNib<T: NibResource>(_ nibResource: T) where T: Reusable, T.T: UICollectionViewCell {
    register(nibResource.instance, forCellWithReuseIdentifier: nibResource.reuseIdentifier.identifier)
  }
  
  func registerNib<T: NibResource>(_ nibResource: T, forSupplementaryViewOfKind kind: String) where T: Reusable, T.T: UICollectionReusableView {
    register(nibResource.instance, forSupplementaryViewOfKind: kind, withReuseIdentifier: nibResource.reuseIdentifier.identifier)
  }
  
  func registerNibs<T: NibResource>(_ nibResources: [T]) where T: Reusable, T.T: UICollectionViewCell {
    nibResources.map(registerNib)
  }
  
  func registerNibs<T: NibResource>(_ nibResources: [T], forSupplementaryViewOfKind kind: String) where T: Reusable, T.T: UICollectionReusableView {
    nibResources.map { self.registerNib($0, forSupplementaryViewOfKind: kind) }
  }
}
